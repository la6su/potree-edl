import { EventDispatcher, type ColorSpace, type Texture, type TextureDataType } from 'three';
import type Extent from '../core/geographic/Extent';
import type MemoryUsage from '../core/MemoryUsage';
import { type GetMemoryUsageContext } from '../core/MemoryUsage';
declare class ImageResult {
    id: string;
    texture: Texture;
    extent: Extent;
    min: number | undefined;
    max: number | undefined;
    /**
     * @param options - options
     */
    constructor(options: {
        /** The unique identifier of this result. */
        id: string;
        /** The texture */
        texture: Texture;
        /** The extent */
        extent: Extent;
        /** The minimum value of this image (if applicable). */
        min?: number;
        /** The maximum value of this image (if applicable). */
        max?: number;
    });
}
export type CustomContainsFn = (extent: Extent) => boolean;
export interface GetImageOptions {
    /** The identifier of the node that emitted the request. */
    id: string;
    /** The extent of the request area. */
    extent: Extent;
    /** The pixel width of the request area. */
    width: number;
    /** The pixel height of the request area. */
    height: number;
    /** If `true`, the generated textures must be readable (i.e `DataTextures`). */
    createReadableTextures: boolean;
    /** The optional abort signal. */
    signal?: AbortSignal;
}
export interface ImageResponse {
    /**
     * The id of the response, used to deduplicate requests.
     */
    id: string;
    /**
     * The request that will generate the image.
     */
    request: (() => Promise<ImageResult>) | (() => ImageResult);
}
export interface ImageSourceOptions {
    /**
     * Should images be flipped vertically during composition ?
     */
    flipY?: boolean;
    /**
     * The data type of images generated.
     * For regular color images, this should be `true`. For images with a high dynamic range,
     * or images that requires additional processing, this should be `false`.
     */
    is8bit?: boolean;
    /**
     * The custom function to test if a given extent is contained in this
     * source. Note: we assume this function accepts extents in this source's CRS.
     */
    containsFn?: CustomContainsFn;
    /**
     * The custom color space of the generated textures.
     * See https://threejs.org/docs/#manual/en/introduction/Color-management for
     * more information. If unspecified, the source considers that 8-bit images are in the sRGB
     * color space, otherwise `NoColorSpace`.
     */
    colorSpace?: ColorSpace;
    /**
     * Is this source able to generate images synchronously ?
     */
    synchronous?: boolean;
    /**
     * The relative [priority](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit#priority) of HTTP requests emitted by this source.
     * @defaultValue `'auto'`
     */
    requestPriority?: RequestPriority;
}
export interface ImageSourceEvents {
    /**
     * Raised when the source's content has been updated.
     */
    updated: {
        extent?: Extent;
    };
}
/**
 * Base class for all image sources. The `ImageSource` produces images to be consumed by clients,
 * such as map layers.
 */
declare abstract class ImageSource<Events extends ImageSourceEvents = ImageSourceEvents> extends EventDispatcher<Events & ImageSourceEvents> implements MemoryUsage {
    readonly isMemoryUsage: true;
    readonly isImageSource: boolean;
    readonly type: string;
    readonly priority: RequestPriority;
    private readonly _customColorSpace;
    /**
     * Gets whether images generated from this source should be flipped vertically.
     */
    readonly flipY: boolean;
    /**
     * Gets the datatype of images generated by this source.
     */
    datatype: TextureDataType;
    readonly containsFn: CustomContainsFn | undefined;
    /**
     * If `true`, this source can immediately generate images without any delay.
     */
    readonly synchronous: boolean;
    /**
     * @param options - Options.
     */
    constructor(options?: ImageSourceOptions);
    getMemoryUsage(_context: GetMemoryUsageContext): void;
    /**
     * Gets the color space of the textures generated by this source.
     */
    get colorSpace(): ColorSpace;
    /**
     * Returns an adjusted extent, width and height so that request pixels are aligned with source
     * pixels, and requests do not oversample the source.
     *
     * @param requestExtent - The request extent.
     * @param requestWidth - The width, in pixels, of the request extent.
     * @param requestHeight - The height, in pixels, of the request extent.
     * @param margin - The margin, in pixels, around the initial extent.
     * @returns The adjusted parameters.
     */
    adjustExtentAndPixelSize(requestExtent: Extent, requestWidth: number, requestHeight: number, margin?: number): {
        extent: Extent;
        width: number;
        height: number;
    } | null;
    /**
     * Returns the CRS of this source.
     *
     * @returns The CRS.
     */
    abstract getCrs(): string;
    /**
     * Returns the extent of this source expressed in the CRS of the source.
     *
     * @returns The extent of the source.
     */
    abstract getExtent(): Extent;
    /**
     * Raises an event to reload the source.
     */
    update(extent?: Extent): void;
    /**
     * Gets whether this source contains the specified extent. If a custom contains function
     * is provided, it will be used. Otherwise,
     * {@link intersects} is used.
     *
     * This method is mainly used to discard non-relevant requests (i.e don't process regions
     * that are not relevant to this source).
     *
     * @param extent - The extent to test.
     */
    contains(extent: Extent): boolean;
    /**
     * Test the intersection between the specified extent and this source's extent.
     * This method may be overriden to perform special logic.
     *
     * @param extent - The extent to test.
     * @returns `true` if the extent and this source extent intersects, `false` otherwise.
     */
    intersects(extent: Extent): boolean;
    /**
     * Initializes the source.
     *
     * @param options - Options.
     * @returns A promise that resolves when the source is initialized.
     */
    initialize(options: {
        /** The target projection. Only useful for sources that are able
         * to reproject their data on the fly (typically vector sources). */
        targetProjection: string;
    }): Promise<void>;
    /**
     * Gets the images for the specified extent and pixel size.
     *
     * @param options - The options.
     * @returns An array containing the functions to generate the images asynchronously.
     */
    abstract getImages(options: GetImageOptions): Array<ImageResponse>;
    /**
     * Disposes unmanaged resources of this source.
     */
    dispose(): void;
}
export default ImageSource;
export { ImageResult };
//# sourceMappingURL=ImageSource.d.ts.map