import { ShaderChunk } from 'three';

// We use non camel-case file names to be as consistent as possible with three.js naming scheme
/* babel-plugin-inline-import './giro3d_colormap_pars_fragment.glsl' */
const giro3d_colormap_pars_fragment = "uniform sampler2D colorMapAtlas; // The color maps atlas\n";
/* babel-plugin-inline-import './giro3d_common.glsl' */
const giro3d_common = "#define M_PI    3.1415926535897932384626433832795\n\n// Pixel formats\nconst int PIXEL_FORMAT_RGBA = 1023;\nconst int PIXEL_FORMAT_RG = 1030;\n\n// Texture types\nconst int TEXTURE_TYPE_FLOAT = 1015;\nconst int TEXTURE_TYPE_UINT8 = 1009;\n\n// Converts a RG / Float color into a RGBA / Unsigned byte color\nvec4 convert_RG_Float_RGBA_UnsignedByte(const in vec4 color, const in float _precision, const in float offset) {\n    float f = (color.r + offset) / _precision;\n\n    vec4 result;\n\n    // https://stackoverflow.com/a/12553149/2704779\n    result.b = floor(f / 256.0 / 256.0);\n    result.g = floor((f - result.b * 256.0 * 256.0) / 256.0);\n    result.r = floor(f - result.b * 256.0 * 256.0 - result.g * 256.0);\n    // now we have a vec3 with the 3 components in range [0..255]. Let's normalize it!\n    result /= 255.0;\n    result.a = color.g;\n\n    return result;\n}\n\nstruct Hillshading {\n    float zenith;     // Zenith of sunlight, in degrees (0 - 90)\n    float azimuth;    // Azimuth on sunlight, in degrees (0 - 360)\n    float intensity;  // The global lighting intensity\n    float zFactor;    // The factor to apply to slopes.\n};\n\nconst int BLENDING_MODE_NONE = 0;\nconst int BLENDING_MODE_NORMAL = 1;\nconst int BLENDING_MODE_ADDITIVE = 2;\nconst int BLENDING_MODE_MULTIPLICATIVE = 3;\n\n/**\n * Describe a color layer's attributes.\n */\nstruct LayerInfo {\n    vec4        offsetScale; // The offset/scale tuple.\n    vec4        color;       // Includes opacity/visible as alpha component\n    vec2        textureSize; // The size, in pixels, of the atlas section mapping to this layer.\n    int         mode;        // The layer mode (normal, mask)\n    #if defined(ENABLE_ELEVATION_RANGE)\n    vec2        elevationRange; // Optional elevation range for the layer. Any fragment above or below this range will be ignored.\n    #endif\n    vec3        brightnessContrastSaturation;\n    int         blendingMode;\n};\n\nstruct NoDataOptions {\n    float       replacementAlpha;\n    float       radius;\n    bool        enabled;\n};\n\nfloat linearTransfer(float v) {\n    return (v < 0.04045) ? v * 0.0773993808 : pow(v * 0.9478672986 + 0.0521327014, 2.4);\n}\n\nvec4 sRGBToLinear( in vec4 srgb ) {\n    float r = linearTransfer(srgb.r);\n    float g = linearTransfer(srgb.g);\n    float b = linearTransfer(srgb.b);\n    return vec4(r, g, b, srgb.a);\n}\n\nfloat getElevationAlpha(vec4 c) {\n    // Elevation textures are in the RG Format, so the transparency/no-data\n    // information is actually in the green channel rather than the alpha channel.\n    return c.g;\n}\n\n/**\n * Returns the elevation value at the specified coordinate, or the default value if the pixel is transparent (no-data).\n */\nfloat getElevationOrDefault(sampler2D tex, vec2 uv, float defaultValue) {\n    vec4 c = texture2D(tex, uv);\n    float alpha = getElevationAlpha(c);\n    if (alpha == 0.0) {\n        return defaultValue;\n    }\n    return c.r;\n}\n\nbool isNoData(sampler2D tex, vec2 uv) {\n    float alpha = getElevationAlpha(texture2D(tex, uv));\n    if (abs(alpha) < 0.001) {\n        return true;\n    }\n\n    return false;\n}\n\nfloat getElevation(sampler2D tex, vec2 uv) {\n    vec4 c = texture2D(tex, uv);\n    return c.r;\n}\n\nvec4 blend(vec4 fore, vec4 back) {\n    if (fore.a == 0. && back.a == 0.) {\n        return vec4(0);\n    }\n    float alpha = fore.a + back.a * (1.0 - fore.a);\n    vec3 color = (fore.rgb * fore.a) + back.rgb * (back.a * (1.0 - fore.a)) / alpha;\n\n    return vec4(color, alpha);\n}\n\nvec4 applyBlending(vec4 fore, vec4 back, int blendingMode) {\n    if (blendingMode == BLENDING_MODE_NORMAL) {\n        return blend(fore, back);\n    } else if (blendingMode == BLENDING_MODE_ADDITIVE) {\n        vec3 rgb = clamp((fore.rgb * fore.a) + (back.rgb * back.a), 0.0, 1.0);\n        return vec4(rgb, 1.0);\n    } else if (blendingMode == BLENDING_MODE_MULTIPLICATIVE) {\n        vec3 rgb = clamp(fore.rgb * back.rgb, 0.0, 1.0);\n        return vec4(rgb, 1.0);\n    } else {\n        return fore;\n    }\n}\n\nvec3 desaturate(vec3 color, float factor) {\n    vec3 lum = vec3(0.299, 0.587, 0.114);\n    vec3 gray = vec3(dot(lum, color));\n    return mix(color, gray, factor);\n}\n\n// This version of atan is numerically stable around zero\n// See https://stackoverflow.com/a/27228836\n// This is used to circumvent a bug on Mac devices where this computation would produce visual artifacts.\nfloat atan2(in float y, in float x) {\n    return x == 0.0 ? sign(y) * M_PI / 2. : atan(y, x);\n}\n\nvec2 computeElevationDerivatives(vec2 dimensions, vec2 uv, sampler2D tex, float elevationFactor, vec4 offsetScale) {\n    ivec2 texSize = textureSize(tex, 0);\n    // Compute pixel dimensions, in normalized coordinates.\n    // Since textures are not necessarily square, we must compute both width and height separately.\n    float width = 1.0 / float(texSize.x);\n    float height = 1.0 / float(texSize.y);\n\n    // Now compute the elevations for the 8 neigbouring pixels\n    // +---+---+---+\n    // | a | b | c |\n    // +---+---+---+\n    // | d | e | f |\n    // +---+---+---+\n    // | g | h | i |\n    // +---+---+---+\n    // Note: 'e' is the center of the sample. We don't use it for derivative computation.\n    float a = elevationFactor * getElevation(tex, uv + vec2(-width, height));\n    float b = elevationFactor * getElevation(tex, uv + vec2( 0.0, height));\n    float c = elevationFactor * getElevation(tex, uv + vec2( width, height));\n    float d = elevationFactor * getElevation(tex, uv + vec2(-width, 0.0));\n    float f = elevationFactor * getElevation(tex, uv + vec2( width, 0.0));\n    float g = elevationFactor * getElevation(tex, uv + vec2(-width, -height));\n    float h = elevationFactor * getElevation(tex, uv + vec2( 0.0, -height));\n    float i = elevationFactor * getElevation(tex, uv + vec2( width, -height));\n\n    float cellWidth = dimensions.x / (offsetScale.z * float(texSize.x));\n    float cellHeight = dimensions.y / (offsetScale.w * float(texSize.y));\n    float dzdx = ((c + 2.0 * f + i) - (a + 2.0 * d + g)) / (8.0 * cellWidth);\n    float dzdy = ((g + 2.0 * h + i) - (a + 2.0 * b + c)) / (8.0 * cellHeight);\n\n    return vec2(dzdx, dzdy);\n}\n\n/**\n * Returns the slope given the derivatives (X and Y derivatives)\n */\nfloat calcSlope( vec2 derivatives ) {\n    // https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-slope-works.htm\n    return atan(sqrt(derivatives.x * derivatives.x + derivatives.y * derivatives.y)); // In radians\n}\n\n/**\n * Returns the aspect (azimuth from the light source)\n */\nfloat calcAspect ( vec2 derivatives ) {\n    // https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-aspect-works.htm\n    float aspect = atan2(derivatives.y, -derivatives.x);\n    if(aspect < 0.0){\n        aspect = M_PI * 0.5 - aspect;\n    } else if (aspect > M_PI * 0.5) {\n        aspect = 2.0 * M_PI - aspect + M_PI * 0.5;\n    } else {\n        aspect = M_PI * 0.5 - aspect;\n    }\n    return aspect; // In radians\n}\n\n/**\n * Linear map between [min1, max1] and [min2, max2]\n */\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat calcHillshade(vec2 tileDimensions, Hillshading hillshading, vec4 offsetScale, sampler2D tex, vec2 uv){\n    // https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-hillshade-works.htm\n    vec2 derivatives = computeElevationDerivatives(tileDimensions, uv, tex, hillshading.zFactor, offsetScale);\n    float slope = calcSlope(derivatives);\n    float aspect = calcAspect(derivatives);\n    float zenith_rad = hillshading.zenith * M_PI / 180.0; // in radians\n    float azimuth_rad = hillshading.azimuth * M_PI / 180.0; // in radians\n    float hillshade = ((cos(zenith_rad) * cos(slope)) + (sin(zenith_rad) * sin(slope) * cos(azimuth_rad - aspect)));\n\n    hillshade = clamp(hillshade, 0., 1.);\n\n    return mix(1., hillshade, hillshading.intensity);\n}\n\nvec2 clamp01(vec2 uv) {\n    return vec2(\n        clamp(uv.x, 0., 1.),\n        clamp(uv.y, 0., 1.));\n}\n\nvec2 computeUv(vec2 uv, vec2 offset, vec2 scale) {\n    return vec2(\n        uv.x * scale.x + offset.x,\n        uv.y * scale.y + offset.y);\n}\n\nfloat squaredDistance(vec2 a, vec2 b) {\n    vec2 c = a - b;\n    return dot(c, c);\n}\n\n/**\n * Returns the value of the valid pixel closest to uv.\n */\nvec4 getNearestPixel(sampler2D tex, vec2 uv, int alphaChannel, float radius, float alpha) {\n    const int SAMPLES = 64;\n    const float fSAMPLES = float(SAMPLES);\n\n    vec4 result = vec4(0, 0, 0, 0);\n    float nearest = 9999.;\n    float sqRadius = radius * radius;\n\n    // This brute force approach produces very good visual results, but is quite costly.\n    // Collect all the samples, then use only the closest valid sample to the requested position.\n    for(int x = 0; x < SAMPLES; ++x) {\n        for(int y = 0; y < SAMPLES; ++y) {\n            float u = float(x) / fSAMPLES;\n            float v = float(y) / fSAMPLES;\n\n            vec2 samplePosition = vec2(u, v);\n\n            vec4 color = texture2D(tex, samplePosition);\n\n            // Is it a valid sample ?\n            if(color[alphaChannel] == 1.) {\n                // We don't need the absolute distance, since we are only interested\n                // in the closest point: we avoid a costly square root computation.\n                float dist = squaredDistance(samplePosition, uv);\n\n                if (dist < nearest && dist <= sqRadius) {\n                    nearest = dist;\n                    result.rgb = color.rgb;\n                    result[alphaChannel] = alpha;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/*\n * Sample the texture, filling no-data (transparent) pixels with neighbouring\n * valid pixels.\n * Note: a pixel is considered no-data if its alpha channel is less than 1.\n * This way, if a bilinear interpolation touches a no-data pixel, it's also considered no-data.\n */\nvec4 texture2DFillNodata(sampler2D tex, vec2 uv, NoDataOptions options, int alphaChannel) {\n    vec4 value = texture2D(tex, uv);\n\n    // Due to how no-data is determined here, we don't support non 1-bit alpha.\n    if(value[alphaChannel] == 1.) {\n        return value;\n    }\n\n    return getNearestPixel(tex, uv, alphaChannel, options.radius, options.replacementAlpha);\n}\n\nconst int INTERPRETATION_RAW = 0;\nconst int INTERPRETATION_SCALED = 2;\nconst int INTERPRETATION_COMPRESS_TO_8BIT = 3;\n\nstruct Interpretation {\n    int mode;\n    bool negateValues;\n    float min; // only for INTERPRETATION_SCALED\n    float max; // only for INTERPRETATION_SCALED\n};\n\nvec4 grayscaleToRGB(vec4 c, Interpretation interpretation) {\n    if (interpretation.mode == INTERPRETATION_RAW) {\n        return c.rrrg;\n    }\n\n    return c.rrra;\n}\n\nconst int OUTPUT_MODE_COLOR = 0;\nconst int OUTPUT_MODE_ELEVATION = 1;\n\n/**\n * Decodes the raw color according to the specified interpretation.\n */\nvec4 decodeInterpretation(vec4 raw, Interpretation interpretation) {\n    vec4 result = raw;\n    if (interpretation.mode == INTERPRETATION_SCALED) {\n        float min = interpretation.min;\n        float max = interpretation.max;\n        float scale = max - min;\n        result = vec4(\n            min + raw.r * scale,\n            min + raw.g * scale,\n            min + raw.b * scale,\n            raw.a);\n    } else if (interpretation.mode == INTERPRETATION_COMPRESS_TO_8BIT) {\n        float min = interpretation.min;\n        float max = interpretation.max;\n        float scale = 1.0 / (max - min);\n        vec3 srgb = vec3(\n            (raw.r - min) * scale,\n            (raw.g - min) * scale,\n            (raw.b - min) * scale);\n\n        result = sRGBToLinear(vec4(srgb, raw.a));\n    }\n\n    if (interpretation.negateValues) {\n        // Note that we don't flip the alpha channel\n        return vec4(-result.r, -result.g, -result.b, result.a);\n    }\n\n    return result;\n}\n\n/**\n * Describes a color map.\n * Color maps are a way to change the color of a texture by\n * mapping the pixel's grayscale color into a value of the lookup table (LUT).\n * The pixel color acts like a UV value, that is then scaled with the min/max values\n * and mapped to the LUT texture.\n * Note: due to limitations in GLSL, the actual LUT texture must be in a separate uniform.\n */\nstruct ColorMap {\n    int         mode;\n    float       min;\n    float       max;\n    float       offset; // The V offset in the color map atlas texture.\n};\n\nconst int COLORMAP_MODE_DISABLED = 0;\nconst int COLORMAP_MODE_ELEVATION = 1;\nconst int COLORMAP_MODE_SLOPE = 2;\nconst int COLORMAP_MODE_ASPECT = 3;\n\nvec4 sampleColorMap(in float t, in float min, in float max, in sampler2D lut, in float v) {\n    t = clamp(t, min, max);\n    t = map(t, min, max, 0., 1.);\n    return texture2D(lut, vec2(t, v));\n}\n\nvec4 computeColorMap(\n    vec2 tileDimensions,\n    LayerInfo layer,\n    sampler2D sampledTexture,\n    ColorMap colorMap,\n    sampler2D lut,\n    vec2 rawUv\n) {\n    float value;\n\n    vec2 uv = computeUv(rawUv, layer.offsetScale.xy, layer.offsetScale.zw);\n\n    if (colorMap.mode == COLORMAP_MODE_ELEVATION) {\n        value = getElevation(sampledTexture, uv);\n    } else {\n        vec2 derivatives = computeElevationDerivatives(tileDimensions, uv, sampledTexture, 1.0, layer.offsetScale);\n        if (colorMap.mode == COLORMAP_MODE_SLOPE) {\n            value = calcSlope(derivatives);\n        } else if (colorMap.mode == COLORMAP_MODE_ASPECT) {\n            value = calcAspect(derivatives);\n        }\n        value *= 180.0 / M_PI; // Convert radians to degrees\n    }\n\n    vec4 rgba = sampleColorMap(value, colorMap.min, colorMap.max, lut, colorMap.offset);\n    float a = texture2D(sampledTexture, uv).a;\n    return vec4(rgba.rgb, rgba.a * a);\n}\n\nvec3 adjustBrightnessContrastSaturation(\n    vec3 rgb,\n    vec3 brightnessContrastSaturation\n) {\n    rgb = (rgb - 0.5) * brightnessContrastSaturation.y + 0.5;\n    rgb += brightnessContrastSaturation.x;\n\n    float luminance = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n    return mix(vec3(luminance), rgb, brightnessContrastSaturation.z);\n}\n";
/* babel-plugin-inline-import './giro3d_compose_layers_pars_fragment.glsl' */
const giro3d_compose_layers_pars_fragment = "#if defined(ENABLE_LAYER_MASKS)\nconst int LAYER_MODE_NORMAL = 0;\nconst int LAYER_MODE_MASK = 1;\nconst int LAYER_MODE_MASK_INVERTED = 2;\n#endif\n\n#if VISIBLE_COLOR_LAYER_COUNT\n#if defined(USE_ATLAS_TEXTURE)\nuniform sampler2D   atlasTexture;         // Atlas texture shared among color layers\n#else\nuniform sampler2D   colorTextures[VISIBLE_COLOR_LAYER_COUNT]; // Individual textures for each color layer\n#endif\nuniform LayerInfo   layers[VISIBLE_COLOR_LAYER_COUNT]; // The color layers' infos\nuniform ColorMap    layersColorMaps[VISIBLE_COLOR_LAYER_COUNT]; // The color layers' color maps\n#endif\n\nvec4 computeColor(vec2 rawUv, vec4 offsetScale, sampler2D tex) {\n    vec2 uv = computeUv(rawUv, offsetScale.xy, offsetScale.zw);\n    return texture2D(tex, uv);\n}\n\nvec4 computeColorLayer(\n    vec2 tileDimensions,\n    sampler2D texture,\n    sampler2D lut,\n    LayerInfo layer,\n    ColorMap colorMap,\n    vec2 uv\n) {\n    if (layer.offsetScale.zw != vec2(0.0)) {\n        vec4 color;\n        if (colorMap.mode != COLORMAP_MODE_DISABLED) {\n            color = computeColorMap(tileDimensions, layer, texture, colorMap, lut, uv);\n        } else {\n            color = computeColor(uv, layer.offsetScale, texture);\n        }\n        vec3 rgb = color.rgb * layer.color.rgb;\n\n        float a = color.a * layer.color.a;\n        return vec4(adjustBrightnessContrastSaturation(rgb, layer.brightnessContrastSaturation), a);\n    }\n\n    return vec4(0);\n}";
/* babel-plugin-inline-import './giro3d_contour_line_fragment.glsl' */
const giro3d_contour_line_fragment = "#if defined(ENABLE_CONTOUR_LINES)\n    // Code inspired from https://github.com/NASA-AMMOS/3DTilesRendererJS/blob/master/example/customMaterial.js\n    // Note: we use the 'height' variable rather than wPosition.z because we want\n    // this feature to work event when terrain deformation is disabled, and height\n    // is always available.\n    vec3 fdx = vec3( dFdx( wPosition.x ), dFdx( wPosition.y ), dFdx( height ) );\n    vec3 fdy = vec3( dFdy( wPosition.x ), dFdy( wPosition.y ), dFdy( height ) );\n    vec3 worldNormal = normalize( cross( fdx, fdy ) );\n\n    // thickness scale\n    float upwardness = dot( worldNormal, vec3( 0.0, 1.0, 0.0 ) );\n    float yInv = clamp( 1.0 - abs( upwardness ), 0.0, 1.0 );\n    float thicknessScale = pow( yInv, 0.4 );\n    thicknessScale *= 0.25 + 0.5 * ( vViewPosition.z + 1.0 ) / 2.0;\n\n    // thickness\n    float thickness = 0.01 * thicknessScale;\n\n    float finalThickness = thickness * contourLines.thickness * 0.15;\n\n    float contourLineAlpha = contourLines.color.a * 1.0;\n\n    drawContourLine(height, contourLines.primaryInterval, finalThickness, vec4(contourLines.color.rgb, contourLineAlpha));\n\n    drawContourLine(height, contourLines.secondaryInterval, finalThickness, vec4(contourLines.color.rgb, contourLineAlpha *  0.4));\n#endif";
/* babel-plugin-inline-import './giro3d_contour_line_pars_fragment.glsl' */
const giro3d_contour_line_pars_fragment = "#if defined(ENABLE_CONTOUR_LINES)\nstruct ContourLine {\n    float thickness; // 1 = default\n    float primaryInterval; // A zero interval disables the line\n    float secondaryInterval; // A zero interval disables the line\n    vec4  color; // Stores both the color and opacity\n};\n\nuniform ContourLine contourLines; // 1 = default\n#endif\n\nvoid drawContourLine(float height, float interval, float thickness, vec4 color) {\n    if (interval > 0.) {\n        float dist = mod(height, interval);\n\n        if (dist <= thickness) {\n            gl_FragColor = blend(color, gl_FragColor);\n        }\n    }\n}";
/* babel-plugin-inline-import './giro3d_fragment_shader_header.glsl' */
const giro3d_fragment_shader_header = "layout(location = 0) out highp vec4 pc_fragColor;\n// GLSL version 3 does not define the built-in gl_FragColor, so we alias it\n#define gl_FragColor pc_fragColor";
/* babel-plugin-inline-import './giro3d_graticule_fragment.glsl' */
const giro3d_graticule_fragment = "#if defined(ENABLE_GRATICULE)\n    drawGraticule(wPosition.xy, graticule);\n#endif";
/* babel-plugin-inline-import './giro3d_graticule_pars_fragment.glsl' */
const giro3d_graticule_pars_fragment = "#if defined(ENABLE_GRATICULE)\nstruct Graticule {\n    float thickness; // 1 = default\n    // xOffset, yOffset, xStep, yStep\n    vec4 position;\n    vec4  color; // Stores both the color and opacity\n};\n\nuniform Graticule graticule;\n\nfloat getGraticuleOpacity(float coordinate, float offset, float step, float thickness) {\n    float dist = mod(coordinate + offset, step);\n\n    float halfThickness = graticule.thickness / 2.0;\n    float falloffWidth = graticule.thickness / 10.0;\n    float fallofStart = halfThickness - falloffWidth;\n\n    if (dist <= halfThickness) {\n        float opacity = 1.0;\n        if (dist > fallofStart) {\n            float normalizedBorderDistance = 1.0 - ((dist - fallofStart) / falloffWidth);\n            opacity *= normalizedBorderDistance;\n        } else if (dist <= falloffWidth) {\n            float normalizedBorderDistance = 1.0 - ((falloffWidth - dist) / falloffWidth);\n            opacity *= normalizedBorderDistance;\n        }\n\n        return opacity;\n    }\n\n    return 0.0;\n}\n\nvoid drawGraticule(vec2 coordinate, Graticule graticule) {\n    vec4 pos = graticule.position;\n    float xOffset = pos[0];\n    float yOffset = pos[1];\n    float xStep = pos[2];\n    float yStep = pos[3];\n\n    if (xStep > 0. && yStep > 0.) {\n        float xOpacity = getGraticuleOpacity(coordinate.x, xOffset, xStep, graticule.thickness);\n        float yOpacity = getGraticuleOpacity(coordinate.y, yOffset, yStep, graticule.thickness);\n\n        float opacity = graticule.color.a * max(xOpacity, yOpacity);\n\n        vec4 finalColor = vec4(graticule.color.rgb, opacity);\n        gl_FragColor = blend(finalColor, gl_FragColor);\n    }\n}\n#endif";
/* babel-plugin-inline-import './giro3d_outline_fragment.glsl' */
const giro3d_outline_fragment = "#if defined(ENABLE_OUTLINES)\nif (vUv.x < OUTLINE_THICKNESS) { // WEST\n    gl_FragColor.rgb = tileOutlineColor;\n} else if (vUv.x > 1.0 - OUTLINE_THICKNESS) { // EAST\n    gl_FragColor.rgb = tileOutlineColor;\n} else if (vUv.y < OUTLINE_THICKNESS) { // NORTH\n    gl_FragColor.rgb = tileOutlineColor;\n} else if (vUv.y > 1.0 - OUTLINE_THICKNESS) { // SOUTH\n    gl_FragColor.rgb = tileOutlineColor;\n}\n#endif";
/* babel-plugin-inline-import './giro3d_outline_pars_fragment.glsl' */
const giro3d_outline_pars_fragment = "#if defined(ENABLE_OUTLINES)\nconst float OUTLINE_THICKNESS = 0.003;\n\nuniform vec3 tileOutlineColor;\n#endif";
/* babel-plugin-inline-import './giro3d_precision_qualifiers.glsl' */
const giro3d_precision_qualifiers = "precision highp float;\nprecision highp int;";
export default function registerChunks() {
  const Giro3dShaderChunk = ShaderChunk;
  Giro3dShaderChunk.giro3d_precision_qualifiers = giro3d_precision_qualifiers;
  Giro3dShaderChunk.giro3d_common = giro3d_common;
  Giro3dShaderChunk.giro3d_outline_pars_fragment = giro3d_outline_pars_fragment;
  Giro3dShaderChunk.giro3d_outline_fragment = giro3d_outline_fragment;
  Giro3dShaderChunk.giro3d_compose_layers_pars_fragment = giro3d_compose_layers_pars_fragment;
  Giro3dShaderChunk.giro3d_colormap_pars_fragment = giro3d_colormap_pars_fragment;
  Giro3dShaderChunk.giro3d_contour_line_pars_fragment = giro3d_contour_line_pars_fragment;
  Giro3dShaderChunk.giro3d_contour_line_fragment = giro3d_contour_line_fragment;
  Giro3dShaderChunk.giro3d_fragment_shader_header = giro3d_fragment_shader_header;
  Giro3dShaderChunk.giro3d_graticule_fragment = giro3d_graticule_fragment;
  Giro3dShaderChunk.giro3d_graticule_pars_fragment = giro3d_graticule_pars_fragment;
}